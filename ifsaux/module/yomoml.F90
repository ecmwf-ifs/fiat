MODULE YOMOML


USE PARKIND1  ,ONLY : JPIM     ,JPRB
USE YOMHOOK  , ONLY : LHOOK, DR_HOOK

IMPLICIT NONE

SAVE

PRIVATE

PUBLIC OML_WAIT_EVENT, OML_SET_EVENT, OML_INCR_EVENT, &
   &   OML_MY_THREAD,  OML_MAX_THREADS , OML_OMP, &
   &   OML_IN_PARALLEL, OML_FUNCT, &
   &   OML_UNSET_LOCK, OML_INIT_LOCK, OML_SET_LOCK, OML_DESTROY_LOCK

INTEGER(KIND=JPIM) :: M_LOCK
INTEGER(KIND=JPIM) :: M_OML_LOCK
INTEGER(KIND=JPIM) :: M_OML_MAX_THREADS = -1


CONTAINS

FUNCTION OML_OMP()
LOGICAL :: OML_OMP
OML_OMP=.FALSE.
!$ OML_OMP=.TRUE.
END FUNCTION OML_OMP

FUNCTION OML_IN_PARALLEL()
LOGICAL :: OML_IN_PARALLEL
LOGICAL :: OMP_IN_PARALLEL
REAL(KIND=JPRB) :: ZHOOK_HANDLE
CALL DR_HOOK('YOMOML:OML_IN_PARALLEL',0,ZHOOK_HANDLE)
OML_IN_PARALLEL=.FALSE.
!$ OML_IN_PARALLEL=((OML_MAX_THREADS() > 1).AND.OMP_IN_PARALLEL())
CALL DR_HOOK('YOMOML:OML_IN_PARALLEL',1,ZHOOK_HANDLE)
END FUNCTION OML_IN_PARALLEL

FUNCTION OML_FUNCT(K,MYLOCK)
LOGICAL :: OML_FUNCT
INTEGER(KIND=JPIM) :: K,MYLOCK
IF(K.EQ.MYLOCK) THEN
 OML_FUNCT =.TRUE.
ELSE
 OML_FUNCT=.FALSE.
ENDIF
END FUNCTION OML_FUNCT

SUBROUTINE OML_UNSET_LOCK(MYLOCK)
INTEGER(KIND=JPIM),optional :: MYLOCK
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!$ CALL DR_HOOK('YOMOML:OML_UNSET_LOCK',0,ZHOOK_HANDLE)
!$ IF(PRESENT(MYLOCK))THEN
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_UNSET_LOCK(MYLOCK)
!$   ENDIF
!$ ELSE
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_UNSET_LOCK(M_LOCK)
!$   ENDIF
!$ ENDIF
!$ CALL DR_HOOK('YOMOML:OML_UNSET_LOCK',1,ZHOOK_HANDLE)
END SUBROUTINE OML_UNSET_LOCK

SUBROUTINE OML_SET_LOCK(MYLOCK)
INTEGER(KIND=JPIM),optional :: MYLOCK
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!$ CALL DR_HOOK('YOMOML:OML_SET_LOCK',0,ZHOOK_HANDLE)
!$ IF(PRESENT(MYLOCK))THEN
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_SET_LOCK(MYLOCK)
!$   ENDIF
!$ ELSE
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_SET_LOCK(M_LOCK)
!$   ENDIF
!$ ENDIF
!$ CALL DR_HOOK('YOMOML:OML_SET_LOCK',1,ZHOOK_HANDLE)
END SUBROUTINE OML_SET_LOCK

SUBROUTINE OML_INIT_LOCK(MYLOCK)
INTEGER(KIND=JPIM),optional :: MYLOCK
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!$ CALL DR_HOOK('YOMOML:OML_INIT_LOCK',0,ZHOOK_HANDLE)
!$ IF(PRESENT(MYLOCK))THEN
!$     CALL OMP_INIT_LOCK(MYLOCK)
!$ ELSE
!$     CALL OMP_INIT_LOCK(M_LOCK)
!$ ENDIF
!$ CALL DR_HOOK('YOMOML:OML_INIT_LOCK',1,ZHOOK_HANDLE)
END SUBROUTINE OML_INIT_LOCK

SUBROUTINE OML_DESTROY_LOCK(MYLOCK)
INTEGER(KIND=JPIM),optional :: MYLOCK
REAL(KIND=JPRB) :: ZHOOK_HANDLE
!$ CALL DR_HOOK('YOMOML:OML_DESTROY_LOCK',0,ZHOOK_HANDLE)
!$ IF(PRESENT(MYLOCK))THEN
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_DESTROY_LOCK(MYLOCK)
!$   ENDIF
!$ ELSE
!$   IF(OML_IN_PARALLEL())THEN
!$     CALL OMP_DESTROY_LOCK(M_LOCK)
!$   ENDIF
!$ ENDIF
!$ CALL DR_HOOK('YOMOML:OML_DESTROY_LOCK',1,ZHOOK_HANDLE)
END SUBROUTINE OML_DESTROY_LOCK

SUBROUTINE OML_WAIT_EVENT(K,MYLOCK)
INTEGER(KIND=JPIM) :: K
INTEGER(KIND=JPIM),OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  DO
    IF(OML_FUNCT(K,MYLOCK)) EXIT
  ENDDO
ELSE
  DO
    IF(OML_FUNCT(K,M_OML_LOCK)) EXIT
  ENDDO
ENDIF
END SUBROUTINE OML_WAIT_EVENT

SUBROUTINE OML_SET_EVENT(K,MYLOCK)
INTEGER(KIND=JPIM) :: K
INTEGER(KIND=JPIM),OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  MYLOCK=K
ELSE
  M_OML_LOCK=K
ENDIF
END SUBROUTINE OML_SET_EVENT

SUBROUTINE OML_INCR_EVENT(K,MYLOCK)
INTEGER(KIND=JPIM) :: K
INTEGER(KIND=JPIM),intent(inout),OPTIONAL :: MYLOCK
IF(PRESENT(MYLOCK))THEN
  MYLOCK=MYLOCK+K
ELSE
  M_OML_LOCK=M_OML_LOCK+K
ENDIF
END SUBROUTINE OML_INCR_EVENT

FUNCTION OML_MY_THREAD()
INTEGER(KIND=JPIM) :: OML_MY_THREAD
INTEGER(KIND=JPIM) OMP_GET_THREAD_NUM
OML_MY_THREAD = 1
!$ OML_MY_THREAD = OMP_GET_THREAD_NUM()+1
END FUNCTION OML_MY_THREAD

FUNCTION OML_MAX_THREADS()
INTEGER(KIND=JPIM) :: OML_MAX_THREADS
INTEGER(KIND=JPIM) OMP_GET_MAX_THREADS
M_OML_MAX_THREADS = 1
!$ M_OML_MAX_THREADS = OMP_GET_MAX_THREADS()
OML_MAX_THREADS = M_OML_MAX_THREADS
END FUNCTION OML_MAX_THREADS

END MODULE YOMOML
