MODULE MPL_DISPLS_CONTAINER_MOD
  USE EC_PARKIND, ONLY : JPIM
  IMPLICIT NONE
  PRIVATE

  TYPE, PRIVATE :: DISPLACEMENTS
    INTEGER(KIND=JPIM) :: REQ
    INTEGER(KIND=JPIM) :: NPROC = 0
    INTEGER(KIND=JPIM), ALLOCATABLE :: SEND(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: RECV(:)
    TYPE(DISPLACEMENTS), POINTER :: PREV
  CONTAINS
    PROCEDURE :: INITIALIZE
    PROCEDURE :: GET_SEND
    PROCEDURE :: GET_RECV
    PROCEDURE :: GET_REQ
    PROCEDURE :: GET_NPROC
  END TYPE DISPLACEMENTS

  TYPE, PUBLIC :: LIST_MANAGER
    TYPE(DISPLACEMENTS), POINTER :: HEAD => NULL()
    INTEGER :: LIST_SIZE = 0
  CONTAINS
    PROCEDURE :: APPEND
    PROCEDURE :: REMOVE_FIRST
    PROCEDURE :: REMOVE_REQ
    PROCEDURE :: CLEAR_LIST
    PROCEDURE :: PRINT_LIST
  END TYPE LIST_MANAGER

  TYPE(LIST_MANAGER),PUBLIC, TARGET :: YDDISPLS_LIST

CONTAINS

  SUBROUTINE INITIALIZE(THIS, REQ, NPROC, SEND_PT, RECV_PT, IERR)
    CLASS(DISPLACEMENTS), TARGET, INTENT(INOUT) :: THIS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: REQ, NPROC
    INTEGER(KIND=JPIM), INTENT(OUT), OPTIONAL :: IERR
    INTEGER(KIND=JPIM), POINTER, INTENT(OUT), OPTIONAL :: SEND_PT(:), RECV_PT(:)

    IF(PRESENT(IERR)) THEN
      IERR = 0
    END IF
    
    IF ( PRESENT(REQ)) THEN
      THIS%REQ = REQ
    END IF
    
    IF (PRESENT(NPROC)) THEN
      IF ( THIS%NPROC == 0 ) THEN
        THIS%NPROC = NPROC
      ELSE
        IF ( NPROC /= THIS%NPROC .AND. PRESENT (IERR)) THEN
          IERR = 2
        END IF
      END IF
    END IF
    
    IF (PRESENT(SEND_PT)) THEN
      IF (THIS%NPROC > 0 ) THEN 
        ALLOCATE(THIS%SEND(THIS%NPROC))
        SEND_PT => THIS%SEND
      ELSE
        IF ( PRESENT(IERR)) IERR = 1
      END IF
    END IF
    
    IF (PRESENT(RECV_PT)) THEN
     IF (THIS%NPROC > 0 ) THEN 
        ALLOCATE(THIS%RECV(THIS%NPROC))
        RECV_PT => THIS%RECV
      ELSE
        IF ( PRESENT(IERR)) IERR = 1
      END IF
    END IF

    THIS%PREV => NULL()

  END SUBROUTINE INITIALIZE

  
  FUNCTION GET_SEND(THIS) RESULT(R)
    IMPLICIT NONE
    CLASS(DISPLACEMENTS), INTENT(INOUT) :: THIS
    INTEGER(KIND=JPIM), ALLOCATABLE ::  R(:)

    R = THIS%SEND
  END FUNCTION GET_SEND

  FUNCTION GET_RECV(THIS) RESULT(R)
    IMPLICIT NONE
    CLASS(DISPLACEMENTS), INTENT(INOUT) :: THIS
    INTEGER(KIND=JPIM), ALLOCATABLE :: R(:)
    
    R = THIS%RECV
  END FUNCTION GET_RECV
  
  FUNCTION GET_REQ(THIS) RESULT(R)
    IMPLICIT NONE
    CLASS(DISPLACEMENTS), INTENT(INOUT) :: THIS
    INTEGER(KIND=JPIM) R
    
    R = THIS%REQ
  END FUNCTION GET_REQ

  FUNCTION GET_NPROC(THIS) RESULT(R)
    IMPLICIT NONE
    CLASS(DISPLACEMENTS), INTENT(INOUT) :: THIS
    INTEGER(KIND=JPIM) R
    
    R = THIS%NPROC
  END FUNCTION GET_NPROC
  

  SUBROUTINE APPEND(THIS, REQ, NPROC, SEND_PT, RECV_PT, NO_NEW_NODE, IERR)
    CLASS(LIST_MANAGER), INTENT(INOUT) :: THIS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: REQ, NPROC
    INTEGER(KIND=JPIM), POINTER, INTENT(OUT), OPTIONAL :: SEND_PT(:), RECV_PT(:)
    LOGICAL, INTENT(IN), OPTIONAL :: NO_NEW_NODE
    INTEGER(KIND=JPIM), INTENT(OUT), OPTIONAL :: IERR
    TYPE(DISPLACEMENTS), POINTER :: NEW_NODE, TMP

    IF (.NOT. ASSOCIATED(THIS%HEAD)) THEN
      ALLOCATE(NEW_NODE)
      CALL NEW_NODE%INITIALIZE(REQ,NPROC,SEND_PT,RECV_PT,IERR)
      THIS%HEAD => NEW_NODE
      THIS%LIST_SIZE = THIS%LIST_SIZE + 1
    ELSE
      IF ( .NOT. PRESENT(NO_NEW_NODE) ) THEN
        ALLOCATE(NEW_NODE)
        CALL NEW_NODE%INITIALIZE(REQ,NPROC,SEND_PT,RECV_PT,IERR)
        NEW_NODE%PREV => THIS%HEAD
        THIS%HEAD => NEW_NODE
        THIS%LIST_SIZE = THIS%LIST_SIZE + 1
      ELSE
        TMP => THIS%HEAD%PREV
        CALL THIS%HEAD%INITIALIZE(REQ,NPROC,SEND_PT,RECV_PT,IERR)
        THIS%HEAD%PREV => TMP
      END IF
    END IF
  END SUBROUTINE APPEND

  SUBROUTINE REMOVE_FIRST(THIS)
    CLASS(LIST_MANAGER), INTENT(INOUT) :: THIS
    TYPE(DISPLACEMENTS), POINTER :: TEMP

    IF (.NOT. ASSOCIATED(THIS%HEAD)) RETURN

    TEMP => THIS%HEAD
    THIS%HEAD => THIS%HEAD%PREV
    DEALLOCATE(TEMP)
    THIS%LIST_SIZE = THIS%LIST_SIZE - 1

  END SUBROUTINE REMOVE_FIRST


  SUBROUTINE REMOVE_REQ(THIS,REQ)
    IMPLICIT NONE
    CLASS(LIST_MANAGER), INTENT(INOUT) :: THIS
    INTEGER, INTENT(IN) :: REQ
    TYPE(DISPLACEMENTS), POINTER :: CURRENT, CURRENT_

    CURRENT => THIS%HEAD
    DO WHILE (ASSOCIATED(CURRENT))
      IF (CURRENT%REQ == REQ) THEN
        IF ( ASSOCIATED(THIS%HEAD, CURRENT) ) THEN
          CURRENT_ => THIS%HEAD
          THIS%HEAD => THIS%HEAD%PREV
          DEALLOCATE(CURRENT_)
          THIS%LIST_SIZE = THIS%LIST_SIZE - 1
          EXIT
        ELSE
          CURRENT_%PREV => CURRENT%PREV
          DEALLOCATE(CURRENT)
          THIS%LIST_SIZE = THIS%LIST_SIZE - 1
          EXIT
        END IF
      ELSE
        CURRENT_ => CURRENT
        CURRENT => CURRENT%PREV
      END IF
    ENDDO
  END SUBROUTINE REMOVE_REQ


  SUBROUTINE CLEAR_LIST(THIS)
    CLASS(LIST_MANAGER), INTENT(INOUT) :: THIS

    DO WHILE(ASSOCIATED(THIS%HEAD))
      CALL THIS%REMOVE_FIRST()
    END DO

  END SUBROUTINE CLEAR_LIST

  SUBROUTINE PRINT_LIST(THIS)
    CLASS(LIST_MANAGER), INTENT(IN) :: THIS
    TYPE(DISPLACEMENTS), POINTER :: CURRENT

    CURRENT => THIS%HEAD
    DO WHILE(ASSOCIATED(CURRENT))
      WRITE(*,*) 'REQUEST    ', CURRENT%REQ
      IF (ALLOCATED(CURRENT%SEND)) WRITE(*,*) 'SEND DISPLS', CURRENT%SEND
      IF (ALLOCATED(CURRENT%RECV)) WRITE(*,*) 'RECV DISPLS', CURRENT%RECV
      CURRENT => CURRENT%PREV
    END DO
  END SUBROUTINE PRINT_LIST

END MODULE MPL_DISPLS_CONTAINER_MOD
