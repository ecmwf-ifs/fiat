! (C) Copyright 2005- ECMWF.
! (C) Copyright 2013- Meteo-France.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.
!

MODULE MPL_ALLTOALLV_MOD

!**** MPL_ALLTOALLV - Everyone sends different data to everyone

!     Purpose.
!     --------
!     Interface to MPI_ALLTOALLV

!     The data may be REAL*8,or INTEGER

!**   Interface.
!     ----------
!        CALL MPL_ALLTOALLV

!        Input required arguments :
!        -------------------------
!           PSENDBUF -  buffer containing message
!                       (can be type  REAL*8 or INTEGER)
!           PRECVBUF -  buffer containing message
!                       (can be type REAL*8 or INTEGER)
!           KRECVCOUNTS-number of elements received from each process
!           KSENDCOUNTS-number of elements to be sent to each process

!        Input optional arguments :
!        -------------------------
!           KCOMM    -  Communicator number if different from MPI_COMM_WORLD
!                       or from that established as the default
!                       by an MPL communicator routine
!           KRECVDISPL -displacements in PRECVBUF at which to place
!                       the incoming data
!           KSENDDISPL -displacements in PSENDBUF from which to send
!                       the data
!           KMP_TYPE -  buffering type (see MPL_BUFFER_METHOD)
!                       overrides value provided to MPL_BUFFER_METHOD
!           CDSTRING -  Character string for ABORT messages
!                       used when KERROR is not provided

!        Output optional arguments :
!        -------------------------
!           KREQUEST -  Communication request
!                       required when buffering type is non-blocking
!           KERROR   -  return error code.     If not supplied,
!                       MPL_ALLTOALLV aborts when an error is detected.

!     Author.
!     -------
!       Y. Tremolet

!     Modifications.
!     --------------
!       Original: 02-03-21
!       Modified : 25-09-02 M.Hamrud - generalize
!      F. Vana  05-Mar-2015  Support for single precision
! ------------------------------------------------------------------

   USE EC_PARKIND  ,ONLY : JPRD, JPIM, JPIB, JPRM
   USE OML_MOD   ,ONLY : OML_MY_THREAD

   USE MPL_MPIF
   USE MPL_DATA_MODULE
   USE MPL_MESSAGE_MOD
   USE MPL_STATS_MOD
   USE MPL_WAIT_MOD
   USE YOMMPLSTATS
   USE MPL_DISPLS_CONTAINER_MOD

   IMPLICIT NONE
   PRIVATE

   LOGICAL :: LLABORT=.TRUE.
   INTEGER(KIND=JPIM) :: IERROR,IPL_NUMPROC,IRECVCOUNT,ISENDCOUNT,IR,IMP_TYPE
   TYPE(MPI_COMM)     :: ICOMM
   LOGICAL :: LLSCALAR

   INTERFACE MPL_ALLTOALLV
      MODULE PROCEDURE MPL_ALLTOALLV_REAL8,MPL_ALLTOALLV_INTEGER,MPL_ALLTOALLV_REAL4
   END INTERFACE

   PUBLIC MPL_ALLTOALLV

CONTAINS
! ------------------------------------------------------------------

   SUBROUTINE MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,KISENDDISPL,KISENDDISPL_PT,&
   & KRECVCOUNTS,KIRECVDISPL,KIRECVDISPL_PT, &
      KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KREQUEST,CDSTRING)


#ifdef USE_8_BYTE_WORDS
      USE MPI4TO8, ONLY : &
         MPI_COMM_SIZE => MPI_COMM_SIZE8
#endif

      IMPLICIT NONE
      INTEGER(KIND=JPIM),INTENT(IN)          :: KRECVCOUNTS(:),KSENDCOUNTS(:)
      INTEGER(KIND=JPIM),TARGET,INTENT(OUT)  :: KISENDDISPL(:),KIRECVDISPL(:)
      INTEGER(KIND=JPIM),POINTER,INTENT(OUT) :: KISENDDISPL_PT(:),KIRECVDISPL_PT(:)
      INTEGER(KIND=JPIM),OPTIONAL,INTENT(IN) :: KSENDDISPL(:),KRECVDISPL(:),KCOMM,KMP_TYPE,KREQUEST
      CHARACTER(LEN=*),INTENT(IN),OPTIONAL :: CDSTRING
      TARGET :: KSENDDISPL,KRECVDISPL
      INTEGER(KIND=JPIM) :: ITID,J
      ITID = OML_MY_THREAD()
      IF(MPL_NUMPROC < 1) CALL MPL_MESSAGE( &
      & CDMESSAGE='MPL_ALLTOALLV: MPL NOT INITIALISED ',LDABORT=LLABORT)

      IF(PRESENT(KCOMM)) THEN
         ICOMM%MPI_VAL=KCOMM
      ELSE
         ICOMM%MPI_VAL=MPL_COMM_OML(ITID)
      ENDIF

      IF(PRESENT(KMP_TYPE)) THEN
         IMP_TYPE=KMP_TYPE
      ELSE
         IMP_TYPE=MPL_METHOD
      ENDIF

      IF(ICOMM%MPI_VAL == MPL_COMM_OML(ITID)) THEN
         IPL_NUMPROC = MPL_NUMPROC
      ELSE
         CALL MPI_COMM_SIZE(ICOMM,IPL_NUMPROC,IERROR)
      ENDIF

      IF(SIZE(KRECVCOUNTS)  < IPL_NUMPROC) THEN
         WRITE(MPL_ERRUNIT,*)'MPL_ALLTOALLV: ERROR KRECVCOUNTS dimension=',&
         & SIZE(KRECVCOUNTS)
         CALL MPL_MESSAGE(CDMESSAGE=&
         & 'MPL_ALLTOALLV: ERROR KRECVCOUNTS dimension is wrong',LDABORT=LLABORT)
      ENDIF

      IF(SIZE(KSENDCOUNTS)  < IPL_NUMPROC) THEN
         WRITE(MPL_ERRUNIT,*)'MPL_ALLTOALLV: ERROR KSENDCOUNTS dimension=',&
         & SIZE(KSENDCOUNTS)
         CALL MPL_MESSAGE(CDMESSAGE=&
         & 'MPL_ALLTOALLV: ERROR KSENDCOUNTS dimension is wrong',LDABORT=LLABORT)
      ENDIF

      IF(PRESENT(KRECVDISPL)) THEN
         KIRECVDISPL_PT => KRECVDISPL
      ELSE
         IF(IMP_TYPE == JP_NON_BLOCKING_STANDARD .OR. IMP_TYPE == JP_NON_BLOCKING_BUFFERED) THEN
            CALL YDDISPLS_LIST%APPEND(KNPROC=IPL_NUMPROC,KRECV_PT=KIRECVDISPL_PT)
         ELSE
            KIRECVDISPL_PT => KIRECVDISPL
         ENDIF
         KIRECVDISPL_PT(:) = 0
         IF(LLSCALAR) THEN
            DO IR=2, IPL_NUMPROC
               KIRECVDISPL_PT(IR) = KIRECVDISPL_PT(IR-1) + 1
            ENDDO
         ELSE
            DO IR=2, IPL_NUMPROC
               KIRECVDISPL_PT(IR) = KIRECVDISPL_PT(IR-1) + KRECVCOUNTS(IR-1)
            ENDDO
         ENDIF
      ENDIF

      DO IR=1, IPL_NUMPROC
         IF(KIRECVDISPL_PT(IR) < 0 .OR. KRECVCOUNTS(IR) < 0) THEN
            WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV: RECV.. < 0 ',&
            & IR,KIRECVDISPL_PT(IR),KRECVCOUNTS(IR)
            CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV',CDSTRING=CDSTRING,KERROR=IERROR,LDABORT=LLABORT)
         ENDIF
         IF(KIRECVDISPL_PT(IR)+KRECVCOUNTS(IR) > IRECVCOUNT) THEN
            WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV:RECV BUFFER TOO SMALL  ', &
            & IR,KIRECVDISPL_PT(IR),KRECVCOUNTS(IR),IRECVCOUNT
            CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV',CDSTRING=CDSTRING,KERROR=IERROR,LDABORT=LLABORT)
         ENDIF
      ENDDO

      IF(PRESENT(KSENDDISPL)) THEN
         KISENDDISPL_PT => KSENDDISPL
      ELSE
         IF(IMP_TYPE == JP_NON_BLOCKING_STANDARD .OR. IMP_TYPE == JP_NON_BLOCKING_BUFFERED) THEN
            CALL YDDISPLS_LIST%APPEND(KSEND_PT = KISENDDISPL_PT,NO_NEW_NODE=.TRUE.)
         ELSE
            KISENDDISPL_PT => KISENDDISPL
         ENDIF
         KISENDDISPL_PT(:) = 0
         IF(LLSCALAR) THEN
            DO IR=2, IPL_NUMPROC
               KISENDDISPL_PT(IR) = KISENDDISPL_PT(IR-1) + 1
            ENDDO
         ELSE
            DO IR=2, IPL_NUMPROC
               KISENDDISPL_PT(IR) = KISENDDISPL_PT(IR-1) + KSENDCOUNTS(IR-1)
            ENDDO
         ENDIF
      ENDIF
      DO IR=1,IPL_NUMPROC
         IF(KISENDDISPL_PT(IR) < 0 .OR. KSENDCOUNTS(IR) < 0) THEN
            WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV:SEND.. <0 ',&
            & IR,KISENDDISPL_PT(IR),KSENDCOUNTS(IR)
            CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV',CDSTRING=CDSTRING,KERROR=IERROR,LDABORT=LLABORT)
         ENDIF
         IF(KISENDDISPL_PT(IR)+KSENDCOUNTS(IR) > ISENDCOUNT) THEN
            WRITE(MPL_ERRUNIT,'(A,4I10)')'MPL_ALLTOALLV:SEND BUFFER TOO SMALL  ', &
            & IR,KISENDDISPL_PT(IR),KSENDCOUNTS(IR),ISENDCOUNT
            CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV',CDSTRING=CDSTRING,KERROR=IERROR,LDABORT=LLABORT)
         ENDIF
      ENDDO

   END SUBROUTINE MPL_ALLTOALLV_PREAMB

   SUBROUTINE MPL_ALLTOALLV_REAL8(PSENDBUF,KSENDCOUNTS,PRECVBUF,KRECVCOUNTS,&
   &KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KERROR,KREQUEST,CDSTRING)


#ifdef USE_8_BYTE_WORDS
      USE MPI4TO8, ONLY : &
         MPI_ALLTOALLV => MPI_ALLTOALLV8
#endif


      IMPLICIT NONE
      REAL(KIND=JPRD),    INTENT(IN)  :: PSENDBUF(:)
      INTEGER(KIND=JPIM), INTENT(IN)  :: KSENDCOUNTS(:), KRECVCOUNTS(:)
      REAL(KIND=JPRD),    INTENT(OUT) :: PRECVBUF(:)
      INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: KSENDDISPL(:), KRECVDISPL(:), KCOMM ,KMP_TYPE
      CHARACTER(LEN=*),   INTENT(IN), OPTIONAL :: CDSTRING
      INTEGER(KIND=JPIM), INTENT(OUT),OPTIONAL :: KREQUEST,KERROR

      INTEGER(KIND=JPIM) :: IRECVDISPL(MPL_NUMPROC),ISENDDISPL(MPL_NUMPROC)
      INTEGER(KIND=JPIM),POINTER :: KISENDDISPL_PT(:),KIRECVDISPL_PT(:)
      TYPE(MPI_REQUEST)  :: IREQUEST_LOCAL

      ISENDCOUNT=SIZE(PSENDBUF)
      IRECVCOUNT=SIZE(PRECVBUF)

#ifdef MPL_CHECK_CONTIG
      IF( .NOT. IS_CONTIGUOUS(PSENDBUF) ) THEN
        CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: SENDBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
      ENDIF

      IF( .NOT. IS_CONTIGUOUS(PRECVBUF) ) THEN
        CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: RECVBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
      ENDIF
#endif

      LLSCALAR=.FALSE.

      IERROR=0
      CALL MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,ISENDDISPL,KISENDDISPL_PT,&
      & KRECVCOUNTS,IRECVDISPL,KIRECVDISPL_PT,KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KREQUEST,CDSTRING)
      IF(IMP_TYPE == JP_BLOCKING_STANDARD .OR. IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
         CALL MPI_ALLTOALLV(PSENDBUF(:),KSENDCOUNTS,KISENDDISPL_PT,MPI_REAL8, &
         & PRECVBUF(:),KRECVCOUNTS,KIRECVDISPL_PT,MPI_REAL8,ICOMM,IERROR)
      ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD .OR. IMP_TYPE == JP_NON_BLOCKING_BUFFERED) THEN
         IF(.NOT.PRESENT(KREQUEST)) CALL MPL_MESSAGE(KERROR=KERROR,CDMESSAGE='MPL_ALLTOALLV',CDSTRING=' KREQUEST MISSING',LDABORT=LLABORT)
         CALL MPI_IALLTOALLV(PSENDBUF(:),KSENDCOUNTS,KISENDDISPL_PT,MPI_REAL8, &
         & PRECVBUF(:),KRECVCOUNTS,KIRECVDISPL_PT,MPI_REAL8,ICOMM,IREQUEST_LOCAL,IERROR)
         KREQUEST=IREQUEST_LOCAL%MPI_VAL
         IF (.NOT. PRESENT(KSENDDISPL) .OR. .NOT. PRESENT(KRECVDISPL)) THEN
            ! in this case the preamble has set the linked list for the missing displacements
            CALL YDDISPLS_LIST%APPEND(KREQ=KREQUEST,NO_NEW_NODE=.TRUE.)
         END IF
      ELSE
         IF(PRESENT(KERROR)) THEN
            IERROR=1
         ELSE
            CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV',CDSTRING=' INVALID METHOD',KERROR=KERROR,LDABORT=LLABORT)
         ENDIF
      ENDIF

      IF(PRESENT(KERROR)) THEN
         KERROR=IERROR
      ELSE
         IF (IERROR/=0) CALL MPL_MESSAGE(CDMESSAGE='ERROR IN MPL_ALLTOALLV',&
         & KERROR=IERROR,LDABORT=LLABORT)
      ENDIF

      IF(LMPLSTATS) THEN
         CALL MPL_SENDSTATS(SUM(KSENDCOUNTS),MPI_REAL8%MPI_VAL)
         CALL MPL_RECVSTATS(SUM(KRECVCOUNTS),MPI_REAL8%MPI_VAL)
      ENDIF

   END SUBROUTINE MPL_ALLTOALLV_REAL8

   SUBROUTINE MPL_ALLTOALLV_REAL4(PSENDBUF,KSENDCOUNTS,PRECVBUF,KRECVCOUNTS,&
   &KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KERROR,KREQUEST,CDSTRING)


#ifdef USE_8_BYTE_WORDS
      USE MPI4TO8, ONLY : &
         MPI_ALLTOALLV => MPI_ALLTOALLV8
#endif


      IMPLICIT NONE
      INTEGER(KIND=JPIM), INTENT(IN)  :: KSENDCOUNTS(:), KRECVCOUNTS(:)
      REAL(KIND=JPRM),    INTENT(IN)  :: PSENDBUF(:)
      REAL(KIND=JPRM),    INTENT(OUT) :: PRECVBUF(:)
      INTEGER(KIND=JPIM), INTENT(IN),OPTIONAL  :: KSENDDISPL(:), KRECVDISPL(:), KCOMM  ,KMP_TYPE
      CHARACTER(LEN=*),   INTENT(IN),OPTIONAL  :: CDSTRING
      INTEGER(KIND=JPIM), INTENT(OUT),OPTIONAL :: KREQUEST,KERROR

      INTEGER(KIND=JPIM) :: IRECVDISPL(MPL_NUMPROC),ISENDDISPL(MPL_NUMPROC)
      INTEGER(KIND=JPIM),POINTER :: KISENDDISPL_PT(:),KIRECVDISPL_PT(:)
      TYPE(MPI_REQUEST)  :: IREQUEST_LOCAL

      ISENDCOUNT=SIZE(PSENDBUF)
      IRECVCOUNT=SIZE(PRECVBUF)

#ifdef MPL_CHECK_CONTIG
      IF( .NOT. IS_CONTIGUOUS(PSENDBUF) ) THEN
            CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: SENDBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
      ENDIF

      IF( .NOT. IS_CONTIGUOUS(PRECVBUF) ) THEN
            CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: RECVBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
      ENDIF
#endif

      LLSCALAR=.FALSE.

      IERROR=0
      CALL MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,ISENDDISPL,KISENDDISPL_PT,&
      & KRECVCOUNTS,IRECVDISPL,KIRECVDISPL_PT,KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KREQUEST,CDSTRING)
      IF(IMP_TYPE == JP_BLOCKING_STANDARD .OR. IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
         CALL MPI_ALLTOALLV(PSENDBUF,KSENDCOUNTS,KISENDDISPL_PT,MPI_REAL4, &
         & PRECVBUF(:),KRECVCOUNTS,KIRECVDISPL_PT,MPI_REAL4,ICOMM,IERROR)
      ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD .OR. IMP_TYPE == JP_NON_BLOCKING_BUFFERED) THEN
         CALL MPI_IALLTOALLV(PSENDBUF,KSENDCOUNTS,KISENDDISPL_PT,MPI_REAL4, &
         & PRECVBUF(:),KRECVCOUNTS,KIRECVDISPL_PT,MPI_REAL4,ICOMM,IREQUEST_LOCAL,IERROR)
         KREQUEST=IREQUEST_LOCAL%MPI_VAL
         IF (.NOT. PRESENT(KSENDDISPL) .OR. .NOT. PRESENT(KRECVDISPL)) THEN
            CALL YDDISPLS_LIST%APPEND(KREQ=KREQUEST,NO_NEW_NODE=.TRUE.)
         ENDIF
      ELSE
         IF(PRESENT(KERROR)) THEN
            IERROR=1
         ELSE
            CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV',CDSTRING=' INVALID METHOD',KERROR=KERROR,LDABORT=LLABORT)
         ENDIF
      ENDIF

      IF(PRESENT(KERROR)) THEN
         KERROR=IERROR
      ELSE
         IF (IERROR/=0) CALL MPL_MESSAGE(CDMESSAGE='ERROR IN MPL_ALLTOALLV',&
         & KERROR=IERROR,LDABORT=LLABORT)
      ENDIF

      IF(LMPLSTATS) THEN
         CALL MPL_SENDSTATS(SUM(KSENDCOUNTS),MPI_REAL4%MPI_VAL)
         CALL MPL_RECVSTATS(SUM(KRECVCOUNTS),MPI_REAL4%MPI_VAL)
      ENDIF

   END SUBROUTINE MPL_ALLTOALLV_REAL4


   SUBROUTINE MPL_ALLTOALLV_INTEGER(KSENDBUF,KSENDCOUNTS,KRECVBUF,KRECVCOUNTS,&
   &KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KERROR,KREQUEST,CDSTRING)


#ifdef USE_8_BYTE_WORDS
      USE MPI4TO8, ONLY : &
         MPI_ALLTOALLV => MPI_ALLTOALLV8
#endif


      IMPLICIT NONE
      INTEGER(KIND=JPIM), INTENT(IN)  :: KSENDBUF(:)
      INTEGER(KIND=JPIM), INTENT(IN)  :: KSENDCOUNTS(:), KRECVCOUNTS(:)
      INTEGER(KIND=JPIM), INTENT(OUT) :: KRECVBUF(:)
      INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: KSENDDISPL(:), KRECVDISPL(:), KCOMM,KMP_TYPE
      CHARACTER(LEN=*),   INTENT(IN), OPTIONAL :: CDSTRING
      INTEGER(KIND=JPIM), INTENT(OUT),OPTIONAL :: KREQUEST,KERROR

      INTEGER(KIND=JPIM) :: IRECVDISPL(MPL_NUMPROC),ISENDDISPL(MPL_NUMPROC)
      INTEGER(KIND=JPIM),POINTER :: KISENDDISPL_PT(:),KIRECVDISPL_PT(:)
      TYPE(MPI_REQUEST)  :: IREQUEST_LOCAL

      ISENDCOUNT=SIZE(KSENDBUF)
      IRECVCOUNT=SIZE(KRECVBUF)

#ifdef MPL_CHECK_CONTIG
      IF( .NOT. IS_CONTIGUOUS(KSENDBUF) ) THEN
            CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: SENDBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
      ENDIF

      IF( .NOT. IS_CONTIGUOUS(KRECVBUF) ) THEN
            CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV: RECVBUF NOT CONTIGUOUS ',LDABORT=LLABORT)
      ENDIF
#endif

      LLSCALAR=.FALSE.

      IERROR=0
      CALL MPL_ALLTOALLV_PREAMB(KSENDCOUNTS,ISENDDISPL,KISENDDISPL_PT,&
      & KRECVCOUNTS,IRECVDISPL,KIRECVDISPL_PT,KSENDDISPL,KRECVDISPL,KMP_TYPE,KCOMM,KREQUEST,CDSTRING)
      IF(IMP_TYPE == JP_BLOCKING_STANDARD .OR. IMP_TYPE == JP_BLOCKING_BUFFERED) THEN
         CALL MPI_ALLTOALLV(KSENDBUF,KSENDCOUNTS,KISENDDISPL_PT,MPI_INTEGER, &
         & KRECVBUF,KRECVCOUNTS,KIRECVDISPL_PT,MPI_INTEGER,ICOMM,IERROR)
      ELSEIF(IMP_TYPE == JP_NON_BLOCKING_STANDARD .OR. IMP_TYPE == JP_NON_BLOCKING_BUFFERED) THEN
         IF(.NOT.PRESENT(KREQUEST)) CALL MPL_MESSAGE(KERROR=KERROR,CDMESSAGE='MPL_ALLTOALLV',CDSTRING=' KREQUEST MISSING',LDABORT=LLABORT)
         CALL MPI_IALLTOALLV(KSENDBUF,KSENDCOUNTS,KISENDDISPL_PT,MPI_INTEGER, &
         & KRECVBUF,KRECVCOUNTS,KIRECVDISPL_PT,MPI_INTEGER,ICOMM,IREQUEST_LOCAL,IERROR)
         KREQUEST=IREQUEST_LOCAL%MPI_VAL
         IF (.NOT. PRESENT(KSENDDISPL) .OR. .NOT. PRESENT(KRECVDISPL)) THEN
            CALL YDDISPLS_LIST%APPEND(KREQ=KREQUEST,NO_NEW_NODE=.TRUE.)
         END IF
      ELSE
         IF(PRESENT(KERROR)) THEN
            IERROR=1
         ELSE
            CALL MPL_MESSAGE(CDMESSAGE='MPL_ALLTOALLV',CDSTRING=' INVALID METHOD',KERROR=KERROR,LDABORT=LLABORT)
         ENDIF
      ENDIF

      IF(PRESENT(KERROR)) THEN
         KERROR=IERROR
      ELSE
         IF (IERROR/=0) CALL MPL_MESSAGE(CDMESSAGE='ERROR IN MPL_ALLTOALLV',&
         & KERROR=IERROR,LDABORT=LLABORT)
      ENDIF

      IF(LMPLSTATS) THEN
         CALL MPL_SENDSTATS(SUM(KSENDCOUNTS),MPI_INTEGER%MPI_VAL)
         CALL MPL_RECVSTATS(SUM(KRECVCOUNTS),MPI_INTEGER%MPI_VAL)
      ENDIF

   END SUBROUTINE MPL_ALLTOALLV_INTEGER

! ------------------------------------------------------------------

END MODULE MPL_ALLTOALLV_MOD
